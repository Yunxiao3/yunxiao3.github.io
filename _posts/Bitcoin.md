# Bitcoin 

​	这篇文章主要记录一下自己对比特币的一些新的理解：1. Bitcoin为什么使用proof of work的机制来确认大多数以达成一致，2. Bitcoin如何通过巧妙的设计在一个开放的系统中保持一致性并且防止forgery double spending。

### 1.Bitcoin的问题

​	Bitcoin本质上就是一个分布式文件系统，但和传统的分布式系统最大不同的地方是bitcoin是一个完全开放的系统，随时都有新的节点加入或者退出，这使得无法确定某一时刻系统中有多少个节点，以及无法避免恶意节点的加入。因此在达成共识的时候就无法使用类似多数表决的方式：1. 无法确定某一时刻系统中共有多少个节点，使得无法判断多少个节点为大多数  2. 因为缺少身份验证，很难找到一个依据避免一票多投，或恶意刷票。

### 2.Bitcoin的解决方案

#### 2.1 避免双花

​	由于完全的开放性带来的上述问题看似无解，但是bitcoin的解决办法非常的巧妙: 如果要完成一次交易（transaction）需要将transaction record 记录在新挖出的block当中（达成共识）。而新的block的产生需要找到一个合适的nonce使得hash出来的值符合规定（hash值前面多少位为0则合法，动态调节挖矿难度）。因此在新产生的block中很容易识别double spending的transaction，并且可以只选择选择一个最先到达的transaction完成交易，避免double spending。但是因为区块是随机产生的（外加网络延时），所以存在某一时刻存在多个新产生的block都符合规定，而此时X如将自己的同一笔钱发送给Y和Z，并且其中一个区块记录X->Y而另外一个区块记录X->Z（可以故意完成这样的操作）。这样区块链就产生了分叉（fork），并且在这个时刻存在double spending的情况。但是区块链中确认transaction完成的标志不是完成写操作（将transaction记录在new block中）而是后面继续有new block不断的产生。

#### 2.1 达成共识

我觉得proof of work这个机制是区块链非常巧妙的地方:

1. 因为产生新的区块需要不断的去计算hash找到一个合法的hash值并且将其广播出去，得到其他节点的认可以后，其他节点将继续沿着该节点继续产生new block，但是最终所有的节点都会重新选择回到最长的链上：如果（len(chainA) > len(chainB）则chainB上的节点将舍弃chainB在chainA后面产生新的block，这样即使一个网络中某一时刻存在多个分叉，但是由于区块的产生速度和算力相关，所以最终所有的节点都会回到增长最快的区块链链上，这样就间接的实现了大多数的机制完成了一次投票（节点越多算力越强链增长的越快->该链上的transaction被认可）。
2. 因为1的缘故区块链中存在短暂的分叉现象但是最终只有一个被大多数节点（算力）认可的（block）分叉是合法的，这样就避免了double spending的情况，。
3. 当然如果恶意节点控制了一半以上的算力，则可以为所欲为了，比如在区块链中的任意一个blockA后面产生新的分叉，并且用自己强大的算力快速生成一条比原有链更长的链，这样就可以将blockA后面原有的block里面的transaction清除，使得之前花出去的钱可以再花一次。但是控制一半的算力对于bitcoin来说不太现实（新发行的有可能），而且生成性的block可以获得比特币奖励收益（ 25 bitcoins），花话这么大的成本花下去单纯为了摧毁bitcoin的信用体系，让自己的硬件和手中的比特币变得一文不值，也是得不偿失。因此从博弈的角度来说，恶意节点也不会选择继续作恶。

