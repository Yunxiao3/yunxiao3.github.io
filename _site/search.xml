<?xml version="1.0" encoding="utf-8"?>
<search>
  
    <entry>
      <title><![CDATA[街拍精选（二）]]></title>
      <url>/%E6%91%84%E5%BD%B1/2019/11/27/Myphotograph3.md/</url>
      <content type="text"><![CDATA[]]></content>
      <categories>
        
          <category> 摄影 </category>
        
      </categories>
      <tags>
        
          <tag> 摄影 </tag>
        
          <tag> 街拍 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[人像精选（一）]]></title>
      <url>/%E6%91%84%E5%BD%B1/2019/11/27/Myphotograph2.md/</url>
      <content type="text"><![CDATA[]]></content>
      <categories>
        
          <category> 摄影 </category>
        
      </categories>
      <tags>
        
          <tag> 摄影 </tag>
        
          <tag> 街拍 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[街拍精选（一)]]></title>
      <url>/%E6%91%84%E5%BD%B1/2019/11/27/Myphotograph1/</url>
      <content type="text"><![CDATA[]]></content>
      <categories>
        
          <category> 摄影 </category>
        
      </categories>
      <tags>
        
          <tag> 摄影 </tag>
        
          <tag> 街拍 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[对Quick Sort的进一步理解]]></title>
      <url>/%E7%AE%97%E6%B3%95/2019/11/05/QuickSort/</url>
      <content type="text"><![CDATA[最近闲来无事，重新学习了一下算法，选用的教材则是大名鼎鼎的《算法导论》。不得不说算法导论真的是一本神书，只是当年自己过于年轻而不得其精髓。在看算法导论之前，自己对快排的理解只停留在实现和使用上，但是对里面的思想却一无所知。总的来说快排是分治思想的一种体现，而书中对快排优化时采用的随机算法和概率分析，让我不禁感慨理论才是指导实践的第一标准。1. 经典的快排算法快速排序的基本思想是：先选一个“主元”，用它对整个待排序列进行筛选，以保证：其左边的元素都不大于它，其右边的元素都不小于它。这样，排序问题就被分割为两个子区间。再分别对子区间排序就可以了。简单的递归实现：void QuickSort(int* array,int left,int right){    //表示已经完成一个组	if(left &gt;= right){ 		return;	}    //获取枢轴的位置，并保证主元左边的元素都不大于它，其右边的元素都不小于它	int index = PartSort(array,left,right);	QuickSort(array,left,index - 1);	QuickSort(array,index + 1,right);}其中代码的核心部分便是 PartSort()函数，而PartSort()函数又有三种实现方式，包括 左右指针法，挖坑法和前后指针法。下面分别介绍这三种算法的实现方式和原理：1. 左右指针法原理：      选取一个关键字(key)作为枢轴，一般取整组记录的第一个数/最后一个，这里采用选取序列最后一个数为枢轴。    设置两个变量left = 0;right = N - 1;从left一直向后走，直到找到一个大于key的值，right从后至前，直至找到一个小于key的值，然后交换这两个数。    重复第三步，一直往后找，直到left和right相遇，这时将key放置left的位置即可。  代码：int PartSort(int* array,int left,int right){	int&amp; key = array[right];	while(left &lt; right){		while(left &lt; right &amp;&amp; array[left] &lt;= key){			++left;		}		while(left &lt; right &amp;&amp; array[right] &gt;= key){			--right;		}		swap(array[left],array[right]);	}	swap(array[left],key);	return left;}2. 挖坑法原理：      选取一个关键字(key)作为枢轴，一般取整组记录的第一个数/最后一个，这里采用选取序列最后一个数为枢轴，也是初始的坑位。    设置两个变量left = 0;right = N - 1;    从left一直向后走，直到找到一个大于key的值，然后将该数放入坑中，坑位变成了array[left]。    right一直向前走，直到找到一个小于key的值，然后将该数放入坑中，坑位变成array[right]。    重复3和4的步骤，直到left和right相遇，然后将key放入最后一个坑位。  代码：int PartSort(int* array,int left,int right){	int key = array[right];	while(left &lt; right){		while(left &lt; right &amp;&amp; array[left] &lt;= key){			++left;		}		array[right] = array[left];		while(left &lt; right &amp;&amp; array[right] &gt;= key){			--right;		}		array[left] = array[right];	 	}	array[right] = key;	return right;}3. 前后指针法原理:      定义变量cur指向序列的开头，定义变量pre指向cur的前一个位置。    当array[cur] &lt; key时，cur和pre同时往后走，如果array[cur]&gt;key，cur往后走，pre留在大于key的数值前一个位置。    当array[cur]再次 &lt; key时，交换array[cur]和array[pre]。  代码int PartSort(int* array,int left,int right){	if(left &lt; right){		int key = array[right];		int cur = left;		int pre = cur - 1;		while(cur &lt; right){            //如果找到小于key的值，并且cur和pre之间有距离时则进行交换。			while(array[cur] &lt; key &amp;&amp; ++pre != cur)	{				swap(array[cur],array[pre]);			}			++cur;		}		swap(array[++pre],array[right]);		return pre;	}	return -1;}2. 快排的时间复杂度分析快速排序的时间复杂度和每次划分的比例相关其公式如下所示:T（n）= T（n/a） + T(n/b) + nT（1）= 0  1 . 最优情况在最优情况下Partition每次都划分的很均匀，即每次都对半分。则   T(n) = 2 T(n/2) + n解得 Ｔ(n) = O(nlogn)2. 最坏情况：而最坏情况Partition每次都划分的极不均匀，即每次都分成1个和n-1个。则  T(n) =  T(n-1) + T(1) + n解得 Ｔ(n) = O(n^2)由于markdown打公式非常累具体过程可以参照：https://www.cnblogs.com/LzyRapx/p/9565827.html3. 随机快排从上面的分析可知，当快排遇到已排好的数据时时间复杂度会降到 O(n^2) 的复杂度，那么怎么避免出现这种情况呢，使得无论输入数据是什么都有一个较为稳定的性能。其实实现的方法非常简单因为传统的快排在选取主元的时候，每次都选取最右/左边的元素。当序列为有序时，会发现划分出来的两个子序列一个里面没有元素，而另一个则只比原来少一个元素。为了避免这种情况，我们可以引入一个随机化量来破坏这种有序状态。即随机取一个主元而不是取最右/左边的元素。代码：int PartSort(int* array,int left,int right){	random = randomValue(left, right);    int key = array[random];	while(left &lt; right){		while(left &lt; right &amp;&amp; array[left] &lt;= key){			++left;		}		array[right] = array[left];		while(left &lt; right &amp;&amp; array[right] &gt;= key){			--right;		}		array[left] = array[right];	 	}	array[right] = key;	return right;}由于使用了随机选取主元的方式，所以随机快排的时间复杂度和输入数据的顺序便不相关了，使得他趋避免了最坏的情况而更加近于平均时间复杂度O(nlogn)使得快排的性能得到了保障，避免了出现性能极差的情况。]]></content>
      <categories>
        
          <category> 算法 </category>
        
      </categories>
      <tags>
        
          <tag> 读书笔记 </tag>
        
          <tag> 《算法导论》 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[我的保研之旅]]></title>
      <url>/%E9%9A%8F%E7%AC%94/2019/10/26/%E6%88%91%E7%9A%84%E4%BF%9D%E7%A0%94%E4%B9%8B%E6%97%85/</url>
      <content type="text"><![CDATA[去年这个时候在网上看到过很多人的保研之旅博客，那个时候觉得非常羡慕。但当自己保完研以后觉得保研其实也没什么，无非是走了一条暂时与大多数人不太一样的路罢了，以后能走多远还是看自身的造化。因此之前完全没有写这篇Blog的打算，但这几天想给自己的Blog吸引一些流量。没办为了恰饭，只能搞一些惊悚如：《我是如何以3.19的绩点和478的四级拿到南开，哈深，华科，电科，中山，浙大等学校的计算机类的offer的》的标题，标题党的标题果然是又臭有又长。]]></content>
      <categories>
        
          <category> 随笔 </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[一点关于Linux文件系统的思考]]></title>
      <url>/linux/2019/10/19/Linux-File-System/</url>
      <content type="text"><![CDATA[在上一篇Blog中我简单的探究了一下Linux中Swap的一些配置对Linux系统性能的影响，这几天有刚好碰到了一些磁盘分区挂载的问题，由于自己的基础不牢在解决这些问题的时候白白浪费了很多时间，所以说基础才是第一生产力啊。话不多说，切入今天的主题 Linux 的磁盘分区与挂载。1. 硬盘分区在了解Linux下的磁盘分区之前，首先我们得了解一下硬盘的分区，因为硬盘的分区是和操作系统没有任何关系的，它是在安装操作系统之前进行了。无论什么操作系统在启动时首先会通过MBR（Master Boot Record是位于磁盘最前边的一段引导Loader代码。）来获得操作系统文件所在的分区，所以一个可引导分区是不能缺少的。这也是为什么新买的硬盘不能直接用的原因。说到这你可能会问磁盘为什么要划分多个分区？我所知道的原因有两个：  一是为了提高管理效率，所有东西如果都放在一个分区，OS管理其起来效率比较低，因为每次要检索的东西太多。  二是提升数据安全性，因为每个分区的数据是分开的，所有系统崩溃以后重装系统并不会影响到数据安全（被覆盖），这样数据恢复起来就比较容易了。在Windows中可能比较直接，而在Linux中需要自己去挂载和管理。下面我们简单看下硬盘的分区结构:硬盘主引导扇区 = 硬盘主引导记录（MBR）+ 硬盘分区表（DPT），一共是512个字节，其中MBR是446，分区表一共64字节，然后是2个字节的结束标志。引导扇区存储在硬盘的0头0道1扇区，也就是Boot Sector。操作系统在启动时通过BIOS程序把Boot Sector读入内存，然后执行其中MBR，这个时候BIOS就把启动交给MBR控制；MBR作用是在4个分区表中搜索标志为活动的分区，找到后把活动分区的第一个扇区读入内存，然后开始执行它，运行特定系统的启动程序(LILO,GRUB,NT Loader);这个时候启动的启动就交给了操作系统的引导程序来控制了。然后操作系统进行一系列的初始化，最后把系统交给系统内核进行管理。2. Linux System分区上面介绍了硬盘分区结构，下面就简单介绍一下各个分区。硬盘分区一共有3种，主分区，扩展分区和逻辑分区。  主分区上可以安装操作系统，因为MBR中记录的主分区信息，系统启动时会到主分区来查找操作系统引导文件，所以操作系统的引导文件必须在主分区中，否则系统就无法启动了。而最多只支持4个主分区（由于硬盘仅仅为分区表保留了64个字节的存储空间，而每个分区的参数占据16个字节，故主引导扇区中总计可以存储4个分区的数据。操作系统只允许存储4个分区的数据。）。  扩展分区并不是一个真实存在的分区，它只是内存管理链表中的一个指针，指示出那一块区域是扩展分区。上面也提到出现扩展分区的原因。所以一个扩展分区也是一个主分区。  而通过在扩展分区中在划分逻辑分区对系统分区进行扩展的分区便是逻辑分区。实际上所有的逻辑分区都是在一个分区类，只是逻辑上分开，这也是叫逻辑分区的原因。但对用户来说一切都是透明了，我们看起来系统中有很多分区。Linux系统中的分区和Windows有很大的区别，对于使Dos或Windows系统来说，有几个分区就有几个驱动器，并且每个分区都会获得一个字母标识符（A,B,C,D），然后就可以选用这个字母来指定在这个分区上的文件和目录，它们的文件结构都是独立的。然而对 Linux用户来说无论有几个分区，都得分给目录使用，它归根结底就只有一个根目录，一个独立且唯一的文件结构。 Linux中每个分区都是用来组成整个文件系统的一部分，因为它采用了一种叫“挂载点”的处理方法，它的整个文件系统中包含了一整套的文件和目录，且将一个分区和一个目录联系起来。这时要载入的一个分区就在Linux的存储空间的某个目录下获得。在网上找到了一张很形象的图：从上图可以更好的理解, 我们安装系统的时候已经把分区1挂载到 / 目录下了。而这个时候没有挂载其他任何分区,所以/ 目录下的所有其他目录都在这个分区下,也就是说,我在任何目录下读写操作实际都是操作的这个1号分区。如果我们想使用其他分区，就必须把这个分区挂载到一个目录下，这个目录可以是已经存在的目录，比如/home,也可以是我们自己建立的目录,比如/oracle。当然有些目录比如/lib, /dev, /etc, /usr这些都不能挂载其他分区,因为他们都存放着系统需要的文件，一旦被挂载其他分区，那没OS就无法找到所需的文件，系统就会崩溃。比如我们把分区2挂载到/usr/X11目录下时,系统就无法通过X11目录找到分区1上的文件,这个时候系统图形界面就无法使用了。 虽然文件还在硬盘上。但目录 — 分区 是通过挂载吧他们联系起来。你更换了分区，也就破坏了联系，就无法在找到之前的文件了。我们在看分区5和分区6，我们把它挂载到/home/ftp 和 /oracle目录下,这个时候我们在操作这2个目录是,就是操作对用的分区。而WINDOWS就没这么复杂,她不是采用树形的结构,每个分区对应一个盘符,一旦建立映射关系就无法在修改。实际上，LINUX的每个挂载了分区的目录就相当于WINDOWS系统中的盘符，比如上面的，/home/ftp 和 /oracle目录我们就可以把她看做一个盘符和一个分区关联。更多详细的内容可以参照：https://wizardforcel.gitbooks.io/vbird-linux-basic-4e/content/20.html]]></content>
      <categories>
        
          <category> Linux </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[一点关于Swap配置对性能影响的思考]]></title>
      <url>/linux/2019/10/12/%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8ELinux-swap%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      <content type="text"><![CDATA[之前在学Linux的时候就了解过，Swap分区是在Linux系统的物理内存不够用的时候，把硬盘空间中的一部分空间释放出来，以供当前运行的程序使用的一种机制，类似于windows的虚拟内存的作用。但是一直停留在对这个概念的了解上面，并没有接触或者感触到Swap对系统性能的影响。直到前段时间在用无服务器下载Linux内核的源码时出现了Out of memory的错误，因为之前使用阿里云相同内存的服务器并没有出现这种情况，所以在排查了一遍以后才发现自己的服务器没有设置Swap分区，导致1G的内存不够用。在将Swap调整到1G后运行正常。为什么不将内存设置的更大些呢？原因很简单因为Swap分区的内存是驻留在硬盘上的，而读写硬盘要比直接使用真实内存慢得多(要慢数千倍，即使是SSD也会慢很多后文会提到)设置过大的Swap内存可能会让系统性能变得异常糟糕。在用Swap解决了内存不足的问题后，我又发现自己的电脑在CPU利用率不高的情况下依旧很卡，之前一直以为是CPU性能跟不上，但仔细排查以后发现自己 /proc/sys/vm/swappiness中的值是默认的60(swappiness=0的时候表示最大限度使用物理内存，然后才是 swap空间，swappiness＝100的时候表示积极的使用swap分区，并且把内存上的数据及时的搬运到swap空间里面。)，这导致在内存充足的情况下Swap分区的利用率比内存还要高。而这极大的拉低了我系统的流畅性。在将swappiness的值设置为5以后自己的电脑无论是在开机还是运行过程都比原来感觉快了许多。查看并修改swappiness的命令：sudo cat /proc/sys/vm/swappinesssudo sysctl -w vm.swappiness=5电脑重启以后设置失效，想永久修改swappiness可以在 /etc/sysctl.conf中添加vm.swappiness=5。当然Swap还有很多东西需要去学习和了解，在面对不同的应用时和不同的场景下Swap大小和swappiness的设置都有着很多学问，在此只是记录一下自己对Swap分区和系统性能之间的一点点思考。]]></content>
      <categories>
        
          <category> Linux </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>/%E9%9A%8F%E7%AC%94/2019/10/11/HelloWorld/</url>
      <content type="text"><![CDATA[很久都没有写博客了，也不知道为什么今天突然心血来潮在Github上搭了一个博客。也许是自己最近这一段时间太过颓废，想尝试着改变自己。其实之前也一直都想写些什么的，但博客放在自己的服务器上总觉得不放心，便一直迟迟没有动笔。而最近刚保完研究，也算比较清闲。其实这段时间自己一直都陷入在一种迷茫而又无所事事的状态，特别是拿到浙软和哈深的offer后一直在纠结于两所学校的选择。直到现在自己也不知道，选择浙软是否是一个好的选择。或许就像《未选择的路》中的那样，自己选择了一条自己觉得更诱人更美丽的道路，多年以后在生活不顺，人生失意的时候也会问问自己当年为什么要选择这条路。     《未选择的路》    黄色的树林里分出两条路可惜我不能同时去涉足我在那路口久久伫立我向着一条路极目望去直到它消失在丛林深处但我却选择了另外一条路它荒草萋萋，十分幽寂显得更诱人，更美丽虽然在这条小路上很少留下旅人的足迹那天清晨落叶满地两条路都未经脚印污染呵，留下一条路等改日再见但我知道路径延绵无尽头恐怕我难以再回返也许多少年后在某个地方，我将轻声叹息将往事回顾：一片树林里分出两条路——而我选择了人迹更少的一条，从此决定了我一生的道路。回首正是：忽忽一场大梦，其乐也无边。幽幽一朝梦觉，其恨也幽远。]]></content>
      <categories>
        
          <category> 随笔 </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
</search>
